cmake_minimum_required(VERSION 2.8.7)

set(HEX_ALPHABET "0123456789ABCDEF")

function(ConvertFromHex HEX DEC)
  string(TOUPPER ${HEX} HEX)
  string(LENGTH "${HEX}" _strlen)
  set(_res 0)
  while(_strlen GREATER 0)
    math(EXPR _res "${_res} * 16")
    string(SUBSTRING "${HEX}" 0 1 NIBBLE)
    string(SUBSTRING "${HEX}" 1 -1 HEX)
    string(FIND ${HEX_ALPHABET} ${NIBBLE} value)
    if(value EQUAL -1)
	    message(FATAL_ERROR "Invalid hex character '${NIBBLE}'")
    endif()
    math(EXPR _res "${_res} + ${value}")
    string(LENGTH "${HEX}" _strlen)
  endwhile()
  set(${DEC} ${_res} PARENT_SCOPE)
endfunction()

# Based on http://www.json.org/JSON_checker/utf8_decode.c
function(DecodeUtf8 hexBytes codePoint)
  string(SUBSTRING ${hexBytes} 0 2 hexByte1)
  ConvertFromHex(${hexByte1} byte1)
  # Zero continuations (0 to 127)
  math(EXPR out "${byte1} & 128")
  if(out EQUAL 0)
    set(${codePoint} ${byte1} PARENT_SCOPE)
    return()
  endif()
  # One continuation (128 to 2047)
  math(EXPR out "${byte1} & 224")
  if(out EQUAL 192)
    string(SUBSTRING ${hexBytes} 2 2 hexByte2)
    ConvertFromHex(${hexByte2} byte2)
    math(EXPR result "((${byte1} & 31) << 6) | ${byte2}")
    if(result GREATER 127)
      set(${codePoint} ${result} PARENT_SCOPE)
      return()
    endif()
  else()
    # Two continuations (2048 to 55295 and 57344 to 65535)
    math(EXPR result "${byte1} & 240")
    if(result EQUAL 224)
      string(SUBSTRING ${hexBytes} 2 2 hexByte2)
      string(SUBSTRING ${hexBytes} 4 2 hexByte3)
      ConvertFromHex(${hexByte2} byte2)
      ConvertFromHex(${hexByte3} byte3)
      math(EXPR result "${byte2} | ${byte3}")
      if(result GREATER -1)
	math(EXPR result "((${byte1} & 15) << 12) | (${byte2} << 6) | ${byte3}")
	if((result GREATER 2047) AND (result LESS 55296 OR result GREATER 57343))
	  set(${codePoint} ${result} PARENT_SCOPE)
	  return()
	endif()
      endif()
    else()
      # Three continuations (65536 to 1114111)
      math(EXPR result "${byte1} & 248")
      if(result EQUAL 224)
	string(SUBSTRING ${hexBytes} 2 2 hexByte2)
	string(SUBSTRING ${hexBytes} 4 2 hexByte3)
	string(SUBSTRING ${hexBytes} 6 2 hexByte4)
	ConvertFromHex(${hexByte2} byte2)
	ConvertFromHex(${hexByte3} byte3)
	ConvertFromHex(${hexByte4} byte4)
	math(EXPR result "${byte2} | ${byte3} | ${byte4}")
	if(result GREATER -1)
	  math(EXPR result "((c & 7) << 18) | (c1 << 12) | (c2 << 6) | c3")
	  if((result GREATER 65535) AND (result LESS 1114112))
	    set(${codePoint} ${result} PARENT_SCOPE)
	    return()
	  endif()
	endif()
      endif()
    endif()
  endif()
  message(FATAL_ERROR "Invalid UTF-8 encoding")
endfunction()

set(inputFile ${CMAKE_ARGV3})
set(outputFile ${CMAKE_ARGV4})
file(READ "${inputFile}" contents)
file(READ "${inputFile}" hexContents HEX)

# Convert the file contents into a list of lines by replacing line endings
# with the list separator
string(REGEX REPLACE ";" "\\\\;" contents ${contents})
string(REGEX REPLACE "\n" ";" contents ${contents})

function(ConvertToHex DEC HEX)
  while(DEC GREATER 0)
    math(EXPR _val "${DEC} % 16")
    math(EXPR DEC "${DEC} / 16")
    string(SUBSTRING ${HEX_ALPHABET} ${_val} 1 _val)
    set(_res "${_val}${_res}")
  endwhile()
  set(${HEX} "0x${_res}" PARENT_SCOPE)
endfunction()

get_filename_component(encname ${inputFile} NAME_WE)
set(output
  "static const struct StaticTableEncoding encoding_${encname} = {\n"
  "  { .decode = &decode_table },\n"
  "  {")
set(index 0)
message("contents: ${contents}")
foreach(line ${contents})
  #message(STATUS ${line})
  string(LENGTH ${line} lineLength)
  message("lineLength: ${lineLength}")
  math(EXPR twiceLineLength "${lineLength} * 2")
  # Convert "A" to 0x41
  string(FIND ${line} "\"" beginQuote)
  if(NOT ${beginQuote} EQUAL -1)
    string(FIND ${line} "\"" endQuote REVERSE)
    message("quotes: ${beginQuote}:${endQuote}")
    if(${beginQuote} EQUAL ${endQuote})
      message(FATAL_ERROR "Line contains only one quote")
    endif()
    math(EXPR beginHexQuote "(${beginQuote} + 1)*2")
    math(EXPR quoteLen "${endQuote}*2 - ${beginHexQuote}")
    message("qlen: ${quoteLen}")
    string(SUBSTRING ${hexContents} ${beginHexQuote} ${quoteLen} hexLine)
    #string(REGEX REPLACE ".." "\\0;" hexLine ${hexLine})
    message("hexLine: ${hexLine}")
    DecodeUtf8(${hexLine} codePoint)
    message("codePoint ${codePoint}")
    ConvertToHex(${codePoint} hexCodePoint)
    STRING(REGEX REPLACE "\"(.+)\"" ${hexCodePoint} line ${line})
  endif()
  # Strip comment
  string(REGEX REPLACE "[ \t\n]*#.*" "" line ${line})
  # Convert 3/1 to [0x31]
  string(REGEX REPLACE "^([0-9]+)/([0-9]+).*" "\\1;\\2" numbers ${line})
  list(GET numbers 0 upperBits)
  list(GET numbers 1 lowerBits)
  math(EXPR res "${upperBits}*16 + ${lowerBits}")
  ConvertToHex(${res} hex)
  string(REGEX REPLACE "^([0-9]+)/([0-9]+)" "[${hex}]" line ${line})
  # Convert U+0041 to 0x0041
  string(REPLACE "U+" "0x" line ${line})
  # Indent and append a comma
  set(line "    ${line},")
  set(output "${output}\n${line}")
  # Add one for the new line character
  # Multiple by two for the hex digit index
  math(EXPR index "${index} + 2*(${lineLength} + 1)")
endforeach()
set(output "${output}\n"
  "  }\n"
  "}\;")

file(WRITE ${outputFile} ${output})
